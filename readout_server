#!/usr/bin/env python

import sys, os

from galton.readout import GaltonBoardRead
galton = GaltonBoardRead()

import matplotlib as mpl
mpl.rcParams['toolbar'] = 'None'

import matplotlib.patches as patches
import matplotlib.pyplot as plt


SERVER_FILE = '/var/www/html/galton_counts.txt'


#### Initial configuration

fig = plt.figure(figsize=(3.4,6.1))
ax = plt.subplot()

def server_state():
    with open(SERVER_FILE, 'r') as f:
        state = f.read()
    return state

def state2int(state):
    res = state.split(',')[1:-1]
    res = map(int,res)
    return res

def pretty_state(state):
    return 'Server: %s' % state

init_state = server_state()
dataplot,  = plt.plot(state2int(init_state),'ok')
count_text = plt.text(0.2,0.02, 
                      pretty_state(init_state), 
                      color='k', 
                      fontsize=12, 
                      transform=fig.transFigure, 
                      clip_on=False
)

#####################################
#### Main functionality is here
#####################################
def get_data():
    """Get data string from the machine, update plot and server"""
    count = galton.numeric_count()
    dataplot.set_data(range(13),count)
    ax.relim()
    ax.autoscale_view()
    count_str = galton.formatted_count()
    count_text.set_text(count_str)
    with open(SERVER_FILE,'w') as f:
        f.write(count_str + '\n')
    plt.draw()

def reset_data():
    """Reset machine counter to 0, update plot and server"""
    galton.reset_counters()
    get_data()

#### Event handlers

# quit with keyboard q
def key_press(event):
    if event.key == 'q':
        sys.exit(0)
fig.canvas.mpl_connect('key_press_event', key_press)


class ActionDict(dict):
    """Map from pickable patch to function. Default does nothing."""
    def __missing__(self, key):
        def do_nothing(): pass
        return do_nothing
action = ActionDict()

# Off switch
button_off = patches.Circle((0.1,0.1),0.1,picker=1, color='red', transform=fig.transFigure, clip_on=False)
action[button_off] = lambda: sys.exit(0)
ax.add_patch(button_off)

# Update switch
button_getdata = patches.Circle((0.25, 0.75), 0.2, picker=1, color='blue', transform=fig.transFigure, clip_on=False)
action[button_getdata] = get_data
ax.add_patch(button_getdata)

# Reset switch
button_reset = patches.Circle((0.75, 0.75), 0.2, picker=1, color='orange', transform=fig.transFigure, clip_on=False)
action[button_reset] = reset_data
ax.add_patch(button_reset)

fig.canvas.mpl_connect('pick_event', lambda ev: action[ev.artist]() )


######### label the switches

textstyle ={
    'color' : 'cyan',
    'fontsize' : 24,
    'transform' : fig.transFigure,
}

plt.text(0.17, 0.75, 'update', **textstyle)
plt.text(0.7, 0.75, 'reset',  **textstyle)


#### fullscreen if we're on the rpi3
if os.uname()[4][:3] == 'arm':
    mgr = plt.get_current_fig_manager()
    mgr.full_screen_toggle()


plt.show()
