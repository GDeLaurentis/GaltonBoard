#!/usr/bin/env python

import sys, os
import numpy as np

import matplotlib as mpl
mpl.rcParams['toolbar'] = 'None'


import matplotlib.pyplot as plt

import matplotlib.gridspec as gridspec

import matplotlib.path as path
import matplotlib.animation as animation

import matplotlib.patches as patches


from matplotlib.widgets import Button

import scipy.integrate as integrate
import matplotlib.animation as animation

from galton.button import connect_buttons



#------------------------------------------------------------
# set up initial state


from galton import box, BOXSIZE, read_board_data

dt = 1. / 100 # 30fps

interval = 40

NBINS = 13
HISTOSIZE=0.9*BOXSIZE

#------------------------------------------------------------
# set up figure and animation
fig = plt.figure(figsize=(3.4,6.1))

gs = gridspec.GridSpec(2, 1, height_ratios=[4, 1], wspace=0.0, hspace=0.0)

ax_h = plt.subplot(gs[1])

hrange=(-3,3)
hbins=np.linspace(-HISTOSIZE,HISTOSIZE,NBINS+1)
hbins[0], hbins[-1] = -5,5

n, bins = np.histogram([], bins=hbins)#, range=hrange)

#n, bins = np.histogram([], bins=NBINS, range=(-HISTOSIZE,HISTOSIZE))
left = np.array(bins[:-1])
right = np.array(bins[1:])
bottom = np.zeros(len(left))
top = bottom + n
nrects = len(left)

nverts = nrects*(1 + 3 + 1)
verts = np.zeros((nverts, 2))
codes = np.ones(nverts, int) * path.Path.LINETO
codes[0::5] = path.Path.MOVETO
codes[4::5] = path.Path.CLOSEPOLY
verts[0::5, 0] = left
verts[0::5, 1] = bottom
verts[1::5, 0] = left
verts[1::5, 1] = top
verts[2::5, 0] = right
verts[2::5, 1] = top
verts[3::5, 0] = right
verts[3::5, 1] = bottom

barpath = path.Path(verts, codes)
patch = patches.PathPatch(
    barpath, facecolor='green', edgecolor='yellow', alpha=0.5)

ax_h.add_patch(patch)
ax_h.set_xlim(left[0], right[-1])
ax_h.set_ylim((0, 80.))
ax_h.set_xticks([])

if False:
    import refdata as ref
    shift = (bins[5]-bins[4])/2
    for i in ref.funnel:
        ax_h.plot(np.array(bins[:-1])+shift,i,'k')

shift = (bins[5]-bins[4])/2
refdata_xs = np.array(bins[:-1])+shift
refdata_xs[0] = refdata_xs[1] - 2*shift
ys = read_board_data()
refdata, = ax_h.plot(refdata_xs, ys, 'ok')

ax = plt.subplot(gs[0],
        aspect='equal', 
        autoscale_on=False,
        xlim=(-BOXSIZE, BOXSIZE), 
        ylim=(-BOXSIZE, BOXSIZE),
        sharex=ax_h
     )
ax.set_xticks([])
ax.set_yticks([])




ms = 6#int(fig.dpi * 2 * box.size * fig.get_figwidth()
       #  / np.diff(ax.get_xbound())[0])

# particles holds the locations of the particles
particles, = ax.plot([], 
                     [], 
                     'bo', ms=ms)

if box.FIXEDGRID:
    fixed, = ax.plot(box.fixed_grid[:, 0], 
                     box.fixed_grid[:, 1], 
                     'ro', ms=ms)

barr_plot = []

# for i,b in enumerate(box.barriers):
#     barr_plot[i].set_data(b.xs, b.ys)
# else:
#     barr_plot[i].set_data([], [])

histo = ax_h.hist([],bins=NBINS)


def draw_barriers(barriers):
    global barr_plot
    for b in barr_plot:
        b.remove()
    barr_plot = []
    for b in box.barriers:
        barr_plot.append(ax.plot(b.xs, b.ys,'k',linewidth=8)[0])

draw_barriers(box.barriers)

def init():
    """initialize animation"""
#    global box, rect
#    particles.set_data([], [])
#    rect.set_edgecolor('k')
    return [particles, patch, refdata] + barr_plot

def animate(i):
    """perform animation step"""
    global box, rect, dt, ax, fig

    if box.redraw:
        draw_barriers(box.barriers)
        box.redraw = False

    if box.getdata:
        refdata.set_data(refdata_xs, read_board_data())
        box.getdata = False

    if not box.PAUSED:
        box.step(dt)

        if box.done():
            box.PAUSED = True
        # update pieces of the animation
        # rect.set_edgecolor('k')
        # alive = box.state[box.dead_pts]
        particles.set_data(box.state[~box.dead][:, 0], 
                           box.state[~box.dead][:, 1])

        data = box.registered_pos()

        hrange=(-3,3)
        hbins=np.linspace(-HISTOSIZE,HISTOSIZE,NBINS+1)
        hbins[0], hbins[-1] = -5,5
        n, bins = np.histogram(data, bins=hbins)#, range=hrange)
        top = bottom + n
        verts[1::5, 1] = top
        verts[2::5, 1] = top

    return [particles, patch, refdata] + barr_plot

# need to hold the handle to avoid GC
ani = animation.FuncAnimation(fig, animate, #frames=600,
                              interval=interval, blit=True, init_func=init)

connect_buttons(ax, fig)

# def onDraw(event):
#     global PAUSED
#     if box.done():
#         PAUSED = True
# #        ani.event_source.stop()


# fig.canvas.mpl_connect('draw_event', onDraw)


# save the animation as an mp4.  This requires ffmpeg or mencoder to be
# installed.  The extra_args ensure that the x264 codec is used, so that
# the video can be embedded in html5.  You may need to adjust this for
# your system: for more information, see
# http://matplotlib.sourceforge.net/api/animation_api.html
#ani.save('particle_box.mp4', fps=30, extra_args=['-vcodec', 'libx264'])

ax.set_frame_on(False)
ax_h.set_frame_on(False)

plt.tight_layout(pad=0)

# fullscreen if we're on the rpi3
if os.uname()[4][:3] == 'arm':
    mgr = plt.get_current_fig_manager()
    mgr.full_screen_toggle()


plt.show()
